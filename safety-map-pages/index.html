<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>안전한 등굣길 </title>
  <link rel="preconnect" href="https://tile.openstreetmap.org" crossorigin>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <style>
    html, body { height:100%; margin:0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans KR', Arial, sans-serif; }
    .app { display:grid; grid-template-columns: 360px 1fr; height:100%; }
    #map { width:100%; height:100%; }
    aside { padding:16px; border-right:1px solid #eee; background:#fafafa; overflow:auto; }
    h1 { font-size:18px; margin:0 0 8px; }
    .desc { font-size:13px; color:#444; line-height:1.4; }
    .legend { margin: 12px 0; font-size:12px; }
    .legend .item { display:flex; align-items:center; gap:8px; margin:6px 0; }
    .swatch { width:24px; height:12px; border-radius:2px; border:1px solid #999; }
    .btn { display:inline-block; font-size:12px; padding:6px 10px; border-radius:6px; border:1px solid #ddd; background:#fff; cursor:pointer; }
    details { background:#fff; border:1px solid #e5e5e5; border-radius:8px; margin:8px 0; }
    summary { cursor:pointer; padding:8px 12px; font-weight:600; }
    .meta { padding:8px 12px; font-size:12px; color:#333; }
    .footer { font-size:11px; color:#666; margin-top:10px; }
    @media (max-width: 800px) {
      .app { grid-template-columns: 1fr; }
      aside { order:2; }
    }
  </style>
</head>
<body>
<div class="app">
  <aside>
    <h1>안전한 등굣길 </h1>
    <p class="desc">

    </p>
    <div class="legend">
      <div class="item"><span class="swatch" style="background:#fee; border-color:#fbb;"></span> 언급 적음</div>
      <div class="item"><span class="swatch" style="background:#fca5a5; border-color:#f87171;"></span> 중간</div>
      <div class="item"><span class="swatch" style="background:#ef4444; border-color:#b91c1c;"></span> 언급 많음</div>
    </div>
    <div class="controls">
      <button class="btn" id="fit">모든 원 보기</button>
      <button class="btn" id="clearCache" title="지오코딩 캐시 삭제">캐시 삭제</button>
    </div>
    <div id="pointsList"></div>
    <div class="footer">
     ⓘ 지오코딩은 공개 API 정책을 존중하기 위해 요청 간 간격을 두고, 브라우저 <code>localStorage</code>에 캐시됩니다.
      위치가 다르다고 판단되면 해당 지점만 수동 좌표로 교체할 수 있습니다(코드 내 <code>manualCoords</code>).
    </div>
  </aside>
  <main id="map"></main>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
const POINTS = [{"name": "학교 앞", "count": 10}, {"name": "여의나루역", "count": 6}, {"name": "여의도 시범아파트", "count": 3}, {"name": "여의도중학교", "count": 3}, {"name": "여의도여자고등학교 길", "count": 3}, {"name": "지하보도", "count": 2}, {"name": "국제금융로", "count": 2}, {"name": "여의나루역1번출구", "count": 1}, {"name": "삼부아파트", "count": 1}, {"name": "정문 앞 횡단보도", "count": 1}, {"name": "대교아파트 앞", "count": 1}, {"name": "정문", "count": 1}, {"name": "학교 정문 앞", "count": 1}, {"name": "삼부아파트 학교", "count": 1}, {"name": "장미아파트 - 횡단보도 - 학교", "count": 1}, {"name": "집에서 도로로 나와서 쭉 직진합니다", "count": 1}, {"name": "아파트에서 상가를 건너서 중학교 도착", "count": 1}, {"name": "한양에서 중학교까지", "count": 1}, {"name": "여고길로 옵니다", "count": 1}, {"name": "삼부아파트를지나 횡단보도를건너 간다", "count": 1}, {"name": "삼주아파트를 통해서 횡단보도를 건너서 간다", "count": 1}, {"name": "한강 자전고길", "count": 1}, {"name": "집 대교 대교상가 삼부 직진", "count": 1}, {"name": "대교상가", "count": 1}, {"name": "아파트 단지-횡단보도-대교상가 앞", "count": 1}, {"name": "횡단보도 건넌다 걷는다 끝", "count": 1}];

// 지역 힌트(검색 보조 문구) - 필요 시 수정
const REGION_HINT = "서울특별시 영등포구 여의도";

// 수동 좌표(지오코딩 대신 확정 좌표를 쓰고 싶을 때만 아래에 추가)
// 예: "여의나루역": [37.5271, 126.9327]
const manualCoords = {
  // "여의도고등학교 정문": [LAT, LNG],
};

const maxCount = Math.max(...POINTS.map(p=>p.count));
const minCount = Math.min(...POINTS.map(p=>p.count));
function scale(val, inMin, inMax, outMin, outMax) {
  if (inMax === inMin) return (outMin + outMax)/2;
  return outMin + (val - inMin) * (outMax - outMin) / (inMax - inMin);
}
function colorForCount(c) {
  const t = scale(c, minCount, maxCount, 0, 1);
  const lerp = (a,b,t)=> Math.round(a+(b-a)*t);
  const c1 = [252,165,165], c2=[239,68,68];
  const r = lerp(c1[0], c2[0], t), g = lerp(c1[1], c2[1], t), b = lerp(c1[2], c2[2], t);
  return `rgba(${r},${g},${b},${0.35 + 0.35*t})`;
}

const map = L.map('map').setView([37.5239,126.9270], 14);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

const bounds = L.latLngBounds();
const circles = [];

// 캐시
const CACHE_KEY = "nominatim_cache_v1";
const geoCache = JSON.parse(localStorage.getItem(CACHE_KEY) || "{}");
function saveCache() { localStorage.setItem(CACHE_KEY, JSON.stringify(geoCache)); }
document.getElementById('clearCache').addEventListener('click', ()=>{ localStorage.removeItem(CACHE_KEY); location.reload(); });

function q(name) {
  if (name === "학교 앞" || name === "정문" || name === "후문" || name.includes("학교 앞")) {
    return "여의도고등학교 정문 " + REGION_HINT;
  }
  return name + " " + REGION_HINT;
}

function addCircle(lat, lng, name, count) {
  const color = colorForCount(count);
  const radius = scale(count, minCount, maxCount, 50, 220); // meters
  const circle = L.circle([lat,lng], {
    radius, color: '#b91c1c', weight: 1, opacity: 0.8, fillColor: color, fillOpacity: 0.6
  }).addTo(map);
  circles.push(circle);
  bounds.extend([lat,lng]);
  circle.bindPopup(`<b>${name}</b><br>언급수: ${count}`);
}

async function geocode(name) {
  if (manualCoords[name]) return manualCoords[name];
  const query = q(name);
  if (geoCache[query]) return geoCache[query];
  const url = new URL("https://nominatim.openstreetmap.org/search");
  url.searchParams.set("q", query);
  url.searchParams.set("format", "json");
  url.searchParams.set("addressdetails", "0");
  url.searchParams.set("limit", "1");
  await new Promise(r=>setTimeout(r, 250));
  const res = await fetch(url.toString(), { headers: { 'Accept-Language': 'ko' } });
  if (!res.ok) throw new Error("Geocoding failed " + res.status);
  const data = await res.json();
  if (data && data.length) {
    const lat = parseFloat(data[0].lat), lon = parseFloat(data[0].lon);
    geoCache[query] = [lat, lon]; saveCache();
    return [lat, lon];
  }
  throw new Error("Not found: " + name);
}

async function render() {
  // 사이드 리스트
  const list = document.getElementById('pointsList');
  list.innerHTML = "";
  POINTS.sort((a,b)=>b.count-a.count).forEach(p=>{
    const el = document.createElement('details');
    const sum = document.createElement('summary');
    sum.textContent = `${p.name} · ${p.count}건`;
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.textContent = "지도상 위치는 OSM/Nominatim 결과입니다. 필요시 manualCoords로 좌표 고정 가능.";
    el.appendChild(sum); el.appendChild(meta);
    list.appendChild(el);
  });

  for (let i=0; i<POINTS.length; i++) {
    const p = POINTS[i];
    try {
      const [lat, lon] = await geocode(p.name);
      addCircle(lat, lon, p.name, p.count);
    } catch (e) {
      console.warn("지오코딩 실패:", p.name, e.message);
    }
  }
  if (bounds.isValid()) map.fitBounds(bounds, { padding:[30,30] });
}

document.getElementById('fit').addEventListener('click', ()=>{ if (bounds.isValid()) map.fitBounds(bounds, { padding:[30,30] }); });

render();
</script>
</body>
</html>
